
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path
import shutil
import sys
from threading import Timer
import time

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage
from auto_video_labeller import image_resize

from widgets import CanvasButton
from tkinter.filedialog import askopenfilename
from pathlib import Path
from auto_labeller import AutoLabeller
from yolov5.utils.general import (check_requirements, cv2)
import os
from PIL import ImageTk, Image
from numpy import asarray
from yolov5.utils.plots import Annotator, colors

from threading import *
VID_FORMATS = [('Video Files','.asf .avi .gif .m4v .mkv .mov .mp4 .mpeg .mpg .ts .wmv')]

dt_frame=Path(__file__).parent/"detect_frame.jpg"

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = "./assets"
def relative_to_assets(path: str) -> Path:
    return Path(__file__).parent/ ASSETS_PATH / Path(path)
class AutoLabellerUI:
    def __init__(self) -> None:   
        self.window = Tk()
        self.window.geometry("1920x1080")
        # setting attribute
        self.window.attributes('-fullscreen', True)
        self.window.attributes('-transparentcolor', "black")
        self.canvas = Canvas(
            self.window,
            bg="#000000",
            height = 1080,
            width = 1920,
            bd = 0,
            highlightthickness = 0,
            relief = "ridge"
        )
        self.canvas.place(x = 0, y = 0)
        image_image_1 = PhotoImage(
            file=relative_to_assets("image_1.png"))
        self.current_image =  self.canvas.create_image(
            960.0,
            540.0,
            image=image_image_1
        )
        self.selectbtn = CanvasButton(
             self.canvas, 42, 38, relative_to_assets("button_1.png"), self.select_video)
        self.labelbtn = CanvasButton(
             self.canvas, 254, 38, relative_to_assets("button_2.png"), self.labelling_thread)
        canvas_btn3 = CanvasButton(
             self.canvas, 1824.0,36.0, relative_to_assets("exit_app.png"), self.destroy)
        canvas_btn4 = CanvasButton(
             self.canvas, 1745.0,36.0, relative_to_assets("minimize.png"), self.minimize)

        
        image_image_2 = PhotoImage(
            file=relative_to_assets("info_back.png"))
        image_2 = self.canvas.create_image(
            222.0,
            912.0,
            image=image_image_2
        )

        self.canvas.create_text(
            8.0,
            856.0,
            anchor="nw",
            text="Gönderim Başarılı\nBaşarılı Gönderim Sayısı: 155\nBaşarısız Gönderim Sayısı: 0\nGönderimde geçen süre: 0.2s\nTespit süresi:1.1s\nGeçen süre:1.3s",
            fill="#FFFFFF",
            font=("Inter Black", 24 * -1)
        )

        self.canvas.create_text(
            292.0,
            780.0,
            anchor="nw",
            text="155/600",
            fill="#FFFFFF",
            font=("Inter Black", 24 * -1)
        )
        self.window.resizable(False, False)
        self.window.mainloop()
    def destroy(self):
        self.window.after_cancel(self.after)
        sys.exit()

    def minimize(self):
        self.window.iconify()
    def select_video(self):
        self.video_file_path = askopenfilename(filetypes=VID_FORMATS) # show an "Open" dialog box and return the path to the selected file
        if self.video_file_path != "":
            f = cv2.VideoCapture(self.video_file_path)
            rval, frame = f.read()
            f.release()
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = image_resize(frame, height = 1080)
            self.change_image(frame=frame)

    def change_image(self, frame):
        img = Image.fromarray(frame)
        self.current_image_image = ImageTk.PhotoImage(image=img)
        self.canvas.itemconfig(self.current_image,image=self.current_image_image)

    def draw_box(self, frame, cocos):
        im0 = asarray(frame)
        im0 = cv2.cvtColor(im0, cv2.COLOR_BGR2RGB)
        annotator = Annotator(
            im0, line_width=1, example=str(self.names))
        for coco in cocos:
            bbox = list(coco["bbox"])
            bbox[2] = bbox[0]+bbox[2]
            bbox[3] = bbox[1]+bbox[3]
            c = int(coco["category_id"])  # integer class
            label = f'{coco["id"]} {coco["category_name"]} {coco["score"]:.2f} {coco["inilebilir"]}'
            color = colors(c, True)
            annotator.box_label(bbox, label, color=color)
        # Stream results
        im0 = annotator.result()
        self.after=self.window.after(50, self.change_image, im0)
    
    def labelling_thread(self):
        self.labelling_thread=Thread(target=self.start_labelling)
        self.labelling_thread.start()

    def start_labelling(self):
        self.selectbtn.activate(False)
        self.labelbtn.activate(False)
        source=self.video_file_path
        yolo_weights='YOLOva2022Best.pt'
        output_folder=str(Path(source).parent)
        conf_thres=0.4
        label_mapper='label_map_uyz_2023.txt'
        classes_txt='classes.txt'
        check_inilebilir=True
        device='cuda:0'
        hide_vid=True
        frame_per_second_to_save=1
        resize_image = True
        (major_ver, minor_ver, subminor_ver) = (cv2.__version__).split('.')
        if frame_per_second_to_save <= 0:
            frame_per_second_to_save = 1
        
        vidcap = cv2.VideoCapture(source)
        if int(major_ver) < 3:
                fps = round(vidcap.get(cv2.cv.CV_CAP_PROP_FPS))
                print(
                    "Frames per second using video.get(cv2.cv.CV_CAP_PROP_FPS): {0}".format(fps))
        else:
            fps = round(vidcap.get(cv2.CAP_PROP_FPS))
            print(
                "Frames per second using video.get(cv2.CAP_PROP_FPS) : {0}".format(fps))
        length = int(vidcap.get(cv2.CAP_PROP_FRAME_COUNT))
        print( length )
        video_name = Path(source).stem  # video ismi alınır kaydetmek için
        count = 0  # sayıcı
        # resimleri kaydetme klasörü
        image_save_folder = os.path.join(output_folder, video_name, "images")
        label_save_folder = os.path.join(output_folder, video_name, "labels")
        # kaydedilecek klasör yoksa oluşturur.
        Path(image_save_folder).mkdir(exist_ok=True, parents=True)
        Path(label_save_folder).mkdir(exist_ok=True, parents=True)

        t_image_per_second = frame_per_second_to_save if fps > frame_per_second_to_save else fps
        success=True
        
        labeller = AutoLabeller(yolo_weights=yolo_weights, device=device, labels_output_folder=label_save_folder,
                                show_vid=not hide_vid, conf_thres=conf_thres, check_inilebilir=check_inilebilir, label_mapper=label_mapper, classes_txt=classes_txt)  # "cpu", # or 'cuda:0'
        self.names=labeller.names
        while success:  # resimleri bitene kadar devam eder
            save= count % round(fps/t_image_per_second) == 0
            success, image = vidcap.read()
            if not success:
                continue
            save_image_path=os.path.join(image_save_folder, f"frame_{str(count).zfill(6)}.jpg")
            (h,w) = image.shape[:2]
            if resize_image and h>1080:
                image = image_resize(image, height = 1080)
            cv2.imwrite(dt_frame, image)
            if save:
                shutil.copyfile(dt_frame, save_image_path)
            source = save_image_path if save else dt_frame
            cocos=labeller.detect(source=source, save_txt=save, info=f"{count}/{length}")
            self.draw_box(image, cocos)
            count += 1
        
        self.selectbtn.activate(True)
        self.labelbtn.activate(True)

AutoLabellerUI()
