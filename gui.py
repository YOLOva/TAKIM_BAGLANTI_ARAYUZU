
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer
from datetime import datetime
import json
import logging
from pathlib import Path
import sys
from threading import Thread
import time

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, PhotoImage, messagebox
from AutoLabeller.utils.image_resize import image_resize
from AutoLabeller.interface.parameters_dialog import ParemetersDialog

from AutoLabeller.interface.widgets import CanvasButton, PauseButton
from pathlib import Path
from AutoLabeller.labeller.auto_labeller import AutoLabeller
from yolov5.utils.general import (cv2)
from PIL import ImageTk, Image
from numpy import asarray
from yolov5.utils.plots import Annotator, colors

from AutoLabeller.utils.params_saver import ParamsSaver
import numpy as np
from src.connection_handler import ConnectionHandler
from src.frame_predictions import FramePredictions
from src.object_detection_model import ObjectDetectionModel
from decouple import config

from src.yolova.status_saver import PredictStatusSaver, SendedPrediction

dt_frame = Path(__file__).parent/"detect_frame.jpg"

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = "./assets"


def relative_to_assets(path: str) -> Path:
    return Path(__file__).parent / ASSETS_PATH / Path(path)
def configure_logger(team_name):
    log_folder = "./_logs/"
    Path(log_folder).mkdir(parents=True, exist_ok=True)
    log_filename = datetime.now().strftime(
        log_folder + team_name + '_%Y_%m_%d__%H_%M_%S_%f.log')
    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)
    logging.basicConfig(filename=log_filename, level=logging.INFO,
                        format='%(asctime)s - %(levelname)s - %(message)s')

class TeamGUI:
    labeller: AutoLabeller = None
    after = None
    label_mapper = 'label_map_uyz_2023.txt'
    classes_txt = 'classes.txt'
    check_inilebilir = True
    hide_vid = True
    resize_image = True
    target_path = ""
    pause=False
    def __init__(self) -> None:
        self.window = Tk()
        self.screen_width = self.window.winfo_screenwidth()
        self.screen_height = self.window.winfo_screenheight()
        self.window.geometry(f"{self.screen_width}x{self.screen_height}")
        # setting attribute
        self.window.attributes('-fullscreen', True)
        self.canvas = Canvas(
            self.window,
            bg="#000000",
            height=self.screen_height,
            width=self.screen_width,
            bd=0,
            highlightthickness=0,
            relief="ridge"
        )
        self.canvas.place(x=0, y=0)
        image_image_1 = PhotoImage(
            file=relative_to_assets("background.png"))
        self.current_image = self.canvas.create_image(
            960.0,
            540.0,
            image=image_image_1
        )
        
        self.pause_button=PauseButton(
            self.canvas, 42, 38.0, value=self.pause)
        self.pause_button.show(False)
        self.stop_button=CanvasButton(
            self.canvas, 42, 139, self.stop, text="Durdur")
        self.stop_button.show(False)
        """ self.selectbtn = CanvasButton(
            self.canvas, 42, 38, self.select_file, text="Dosya Seç")
        self.selectfolderbtn = CanvasButton(
            self.canvas, 258, 38, self.select_folder, text="Klasör Seç") """
        self.startbtn = CanvasButton(
            self.canvas, 42, 38, self.main_thread, text="Başlat")
        self.parbtn = CanvasButton(
            self.canvas, 258, 38, self.open_paremetre_dialog, text="Parametreler")
        self.clearbtn = CanvasButton(
            self.canvas, 474, 38, self.clear, text="Kaydı Temizle")
        
        self.destroy_button=CanvasButton(
            self.canvas, 1824.0, 36.0, self.destroy, text="X", back_image="button_background2.png")
        
        
        self.minimize_button=CanvasButton(
            self.canvas, 1745.0, 36.0, self.minimize, text="-", back_image="button_background2.png")
        """ self.tracker_checkbox = CanvasCheckBox(
            self.canvas, 46, 139, True, text="Tracker Kullan")
        self.sahi_checkbox = CanvasCheckBox(
            self.canvas, 268, 139, True, text="SAHI Kullan") """
        image_image_2 = PhotoImage(
            file=relative_to_assets("info_back2.png"))
        self.info_back=self.canvas.create_image(
            222.0,
            908.0,
            image=image_image_2
        )
        logobtn=CanvasButton(self.canvas, 1730.0, 860.0,  self.logoClick,"logo.png")

        self.infolabel = self.canvas.create_text(
            16.0,
            809.0,
            anchor="nw",
            text="Başarılar :)",
            fill="#FFFFFF",
            font=("Inter Black", 24 * -1)
        )
        self.canvas.itemconfig(self.infolabel)
        self.percentlabel = self.canvas.create_text(
            292.0,
            780.0,
            anchor="nw",
            text="0/0",
            fill="#FFFFFF",
            font=("Inter Black", 24 * -1)
        )


        self.stop=False
        #self.startbtn.show(False)
        self.status_saver = PredictStatusSaver()
        if len(self.status_saver.sended_predictions) == 0:
            self.clearbtn.show(False)
        def fun(event):
            if(event.keysym=='h'):
                self.hideall(not self.is_show_elements)

        self.window.bind("<KeyRelease>", fun)
        self.window.mainloop()
        self.window.resizable(False, False)

        self.window.mainloop()
    is_show_elements=True
    def logoClick(self):
        messagebox.showinfo("Bilgi","Emre Aydemir Gururla Sunar.")

    def hideall(self, value):
        self.is_show_elements=value
        self.pause_button.show(value)
        self.stop_button.show(value)
        self.clearbtn .show(value)
        self.startbtn.show(value)
        self.parbtn.show(value)
        self.destroy_button.show(value)
        self.minimize_button.show(value)
    def destroy(self):
        if self.after is not None:
            self.window.after_cancel(self.after)
        sys.exit()
    
    def stop(self):
        self.stop=True

    def minimize(self):
        self.window.iconify()
    
    def show_elements(self, value):
        self.is_show_elements=value
        self.startbtn.show(value)
        #self.parbtn.show(value)
        self.pause_button.show(not value)
        self.stop_button.show(not value)
        self.clearbtn.show(len(self.status_saver.sended_predictions) > 0 and value)

    def open_paremetre_dialog(self):
        d = ParemetersDialog(self.window, "Parametreleri Düzenle")


    def change_image(self, frame):
        frame = image_resize(frame, width=self.screen_width, height=self.screen_height)
        img = Image.fromarray(frame)
        self.current_image_image = ImageTk.PhotoImage(image=img)
        self.canvas.itemconfig(
            self.current_image, image=self.current_image_image)

    def calculate_object_count_on_center(self, cocos, frame):
        (h, w) = frame[:2]
        center_bbox = [0.25, 0.25, 0.75, 0.75]
        corner_indexes = [(0, 1), (0, 3), (2, 1), (2, 3)]
        center_count = 0
        for coco in cocos:
            bbox = list(coco["bbox"])
            bbox[2] = bbox[0]+bbox[2]
            bbox[3] = bbox[1]+bbox[3]
            for corner_index in corner_indexes:
                corner = (bbox[corner_index[0]], bbox[corner_index[1]])
                if center_bbox[0] <= corner[0] <= center_bbox[2] and center_bbox[1] <= corner[1] <= center_bbox[3]:
                    center_count += 1
                    break
        return center_count
    def update_text(self, message, predictions: FramePredictions, success_count, fail_count, index, max_index):
        process_text = f"""
        {message}
        Başarılı Gönderim Sayısı: {success_count}
        Başarısız Gönderim Sayısı: {fail_count}
        İndirmede geçen süre: {round(predictions.download_time,2)}s
        Tespit süresi:{round(predictions.detection_time,2)}s
        Gönderimde geçen süre: {round(predictions.send_time,2)}s
        80 frame bekleme süresi:{round(predictions.sleep_time,2)}s
        Geçen süre:{round(predictions.total_time,2)}s"""
        percent_text = f"{index}/{max_index}"
        self.canvas.itemconfig(self.infolabel, text=process_text)
        self.canvas.itemconfig(self.percentlabel, text=percent_text)
    def update_text2(self, process_text, percent_text="0/0"):
        self.canvas.itemconfig(self.infolabel, text=process_text)
        self.canvas.itemconfig(self.percentlabel, text=percent_text)
    
    def draw_box(self, prediction: FramePredictions, frame):
        #self.canvas.itemconfig(self.infolabel, text=info)
        im0 = asarray(frame)
        im0 = cv2.cvtColor(im0, cv2.COLOR_BGR2RGB)
        names=["arac", "insan", "uap", "uai"]
        annotator = Annotator(
            im0, line_width=1, example=str(names))
        (h, w) = im0.shape[:2]
        for i, coco in enumerate(prediction.cocos):
            bbox = list(coco["bbox"])
            bbox[2] = bbox[0]+bbox[2]
            bbox[3] = bbox[1]+bbox[3]
            bbox=[a*(frame.shape[1] if i%2==0 else frame.shape[0]) for i, a in enumerate(bbox)]
            c = int(coco["category_id"])  # integer class
            label = f'{coco["id"]} {coco["category_name"]}-{names[prediction.detected_objects[i].cls]} {coco["score"]:.2f} {coco["inilebilir"]}'
            color = colors(c, False)
            annotator.box_label(bbox, label, color=color)
        # Stream results
        count = self.calculate_object_count_on_center(prediction.cocos, frame)
        bbox = [w/4, h/4, w*3/4, h*3/4]
        annotator.box_label(bbox, f"Center {count}", (0, 0, 0))
        im0 = annotator.result()
        self.after = self.window.after(50, self.change_image, im0)

    def main_thread(self):
        try:
            self.main_thread = Thread(
                target=self.start_run, daemon=True).start()
        except (KeyboardInterrupt, SystemExit):
            self.destroy()

    def clear(self):
        self.status_saver.clear()
        if len(self.status_saver.sended_predictions) == 0:
            self.clearbtn.show(False)


    def isStop(self):
        if self.stop:
            self.stop=False
            return True
        return False


    def detect(self, img:str|np.ndarray, dest:str, save_txt=True, save_img=False, message=""):
        t1=time.perf_counter()
        paramsaver=ParamsSaver()
        self.params=paramsaver.getParams()
        if type(img) is not np.ndarray:
            img=cv2.imread(img)
        self.labeller.detect(dest, img, save_txt)
        if self.params.resize_img.get() and img.shape[0] > self.params.resize_height.get():
            img = image_resize(img, height=self.params.resize_height.get(), width=self.params.resize_width.get())
        cocos = self.labeller.detect(
                    img=img, source=dest, save_txt=save_txt)
        t2=time.perf_counter()
        self.draw_box(cocos, f"{message}   {(t2-t1):.2f}s")
        if save_img:
            cv2.imwrite(dest, img)
        return cocos
        



    def runner(self):
        config.search_path = "./config/"
        team_name = config('TEAM_NAME')
        password = config('PASSWORD')
        evaluation_server_url = config("EVALUATION_SERVER_URL")
        configure_logger(team_name)
        detection_model = ObjectDetectionModel(evaluation_server_url)
        server = ConnectionHandler(
            evaluation_server_url, username=team_name, password=password)
        frames_json = server.get_frames()
        images_folder = "./_images/"
        Path(images_folder).mkdir(parents=True, exist_ok=True)
        num_error = 0
        num_success = 0
        if len(frames_json) == 0:
            self.update_text2("Frame listesi boş!")
        else:
            
            for index, frame in enumerate(frames_json):
                while self.pause_button.pause and not self.stop:
                    continue
                if self.isStop():
                    break
                if (not self.status_saver.isSended(index)):
                    t1_total = time.perf_counter()
                    predictions = FramePredictions(
                        frame['url'], frame['image_url'], frame['video_name'], frame["session"].split("/")[-2])
                    predictions = detection_model.process(
                        index, predictions, evaluation_server_url)
                    self.draw_box(predictions, detection_model.labeller.predictor.frame)
                    tsend = time.perf_counter()

                    # 80 Frame Limiti Çözümü
                    if len(self.status_saver.sended_predictions) >= 80:
                        before_80 = self.status_saver.sended_predictions[-80]
                        passed_between_80 = tsend - before_80.sendTime
                        if passed_between_80 <= 60:
                            predictions.sleep_time=60-passed_between_80
                            time.sleep(predictions.sleep_time)

                    result = server.send_prediction(predictions)
                    t2_total = time.perf_counter()
                    predictions.total_time = t2_total-t1_total
                    predictions.send_time = t2_total-tsend
                    response_json = json.loads(result.text)
                    success = True
                    message = "Gönderim Başarılı"
                    if result.status_code == 201:
                        self.status_saver.addSendedPrediction(
                            SendedPrediction(index, t2_total))

                    elif "You have already send prediction for this frame." in response_json["detail"]:
                        self.status_saver.addSendedPrediction(
                            SendedPrediction(index, t2_total))
                        message = "Frame daha önce gönderilmiş"
                    # dakikada 80 limiti aşılmışsa
                    elif ("You do not have permission to perform this action." in response_json["detail"] 
                    or "Your requests has been exceeded 80/m limit." in response_json["detail"]):
                        num_error += 1
                        success = False
                        message = "Dakika'da 80 frame limiti aşıldı"
                    else:
                        num_error += 1
                        success = False
                        message = response_json["detail"]
                    if success:
                        num_success += 1
                    self.update_text(message=message, predictions=predictions, success_count=num_success,
                                     fail_count=num_error, index=index+1, max_index=len(frames_json))
                else:
                    num_success += 1
            self.update_text2(
                "Oturum Tamamlandı!" if num_success==len(frames_json) else"Gönderilmemiş frameler var!", f"{num_success}/{len(frames_json)}")

    def start_run(self):
        self.show_elements(False)
        self.runner()
        self.pause_button.onValue(False)
        self.show_elements(True)
        
